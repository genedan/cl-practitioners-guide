Introduction
============

Practicing actuaries are managing more complex system and workflows every day, especially in reserving. While reserving in of itself is a complex topic, many actuaries prefer routine workflows that are intuitive and easy to manage.

This paper discusses practical considerations on the analytical and workflow structure of setting an unpaid claim estimate. Literature abounds on actuarial methods and assumptions used to tackle specific reserving issues, but there is very little research into the best practices of managing actuarial reserving workflows. Today, management teams of companies increasingly desire

1.	Faster speed in end-to-end analysis,
2.	Lower cost in running a reserving shop, and
3.	More detailed insight into the drivers of loss experience

These pressures continue to shape the evolution of reserving against a backdrop of technology advancements that are outpacing advancements in actuarial reserving processes.  They point to the need to scale up the reserving function to meet the needs of the business.

At the heart of our recommendation for scaling up a reserving function is the establishment of standards that improve the ability to scale. Standards are used throughout a variety of industries to establish common language, seamlessly integrate different technologies, and improve interoperability where possible. We propose a standard for data management of the loss triangle along with a standard for building actuarial models with an explicit declaration of model assumptions.

Our belief is that these standards can improve the efficacy of a reserving function by preserving traditional techniques and standards of practice while simultaneously enabling a foundation for more advanced data and modeling needs.  These standards are borne out of the idea that a separation of concerns is a good thing for scaling up the complexity of a workflow.

In order to stay true with the intentions of this work's title, we have chosen to write this paper using
open-source tools. The contents of Chapters 1, 2, and 3 was written using a markup language called reStructuredText.
Chapter 4, which covers the chainladder-python tutorial, was written using a combination of Markdown and Python in
a Jupyter notebook file. Together, these documents were compiled using a Python package called Sphinx which in turn
uses a LaTeX engine to generate this PDF. Moreover, this project is version controlled via Git.

The paper's source code is available on a GitHub repository via the following link: https://github.com/genedan/cl-practitioners-guide. On this repo, readers can examine the development of this paper from inception
to publication, and can even see the challenges faced by the authors by examining the project's issues page. By making
the project's source code and development history public, we intend to demonstrate that this paper follows the
guidelines that it prescribes.