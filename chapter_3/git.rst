Git and Version Control Management
====================================

Global Information Tracker, or more commonly known as git, is a distributed version control system that can track changes within a repository, or folder. It is very commonly used by engineers or programmers to control source code versioning collaboratively. The "distributed" version control system just means that the local machines each have a local complete copy of the complete repository. That way, each team member can view, modify, and save changes to the repository without relying on a central system or impact others while they work on specific files.

There are in fact many versions of distributed source code management systems, such as Mercurial and Bazaar. These distributed version control systems help software development teams create strong workflows and hierarchies, with each developer pushing code changes to their own repository and maintainers setting a code review process to ensure only quality code is merged to the main branch, which can then be hosted on a centralized server.


Benefits of Distributed Version Control Systems
------------------------------------------------------------------------
- **Reliable backup copies**: A distributed version control system can be seen as a collection of backups. When a team member copies a repository, they create an offline backup. If the server crashes, or is in anyway jeopardized, every local copy serves as a backup. Unlike centralized systems, these distributed systems eliminates reliance on a single backup, enhancing reliability. Although some may think multiple copies waste storage space, most development involves plain text or code files, so the storage impact is minimal.

- **Flexibility for offline work**: A distributed version control system allows development activities to be performed offline, with internet needed only for confirming final changes to the main repository on a server. Individual users have a local copy of the repository, enabling them to view history and make changes independently. This flexibility lets team members address issues promptly and efficiently. Having a local copy also speeds up common tasks, as developers don't need to wait for server to respond, thereby boosting productivity and reducing frustration.

- **Quicker feedback for experimentation**: A distributed version control system simplifies branching by keeping the entire repository history locally, enabling quick code implementation, experimentation, and review. Developers benefit from fast feedback and can experiment new features by comparing changes locally before merging. This can greatly reduce merge conflicts, and it allows for easy access to the full local history helps in identifying bugs, tracking changes, and reverting to previous versions.

- **Faster merging**: Distributed version control systems enable quick code merging without needing remote server communication. Unlike centralized systems, they support diverse branching strategies (such as for implementation of new features, or testing in different code environments). This accelerates delivery and boosts business value by allowing team members to focus on innovation instead of dealing with slow builds.


Git: An Example of a Distributed Version Control System 
------------------------------------------------------------------------

It is important to note that git is only an example of a distributed version control system, and there are many other tools of version control systems.

It is also important to know that git does not equate to GitHub, or GitLab, despite their similar names. Git is the version control tracking system, which is a tool, that allows you to track code changes, and GitHub, GitLab, or Bitbucket are the centralized server that act as hosts to your repositories. GitHub by Microsoft and GitLab by its eponymous organization. They are each spaces for developers to work on Git projects, collaborate, and share and test their work. Both repositories are constantly evolving and have attracted user bases with millions of members.


Commonly Used Git Commands
------------------------------------------------------------------------

There are many git commands, however, a practicing actuary might be able to get by with just knowing a few. Let's explore some of the popular commands and how it might can relate to how an actuary that use a centralized folder sharing system for collaboration.

:code:`git clone`: The :code:`git clone` command downloads existing source code from a remote repository (e.g., GitHub), creating an identical copy of the latest project version on your local computer. This is similar to copying all the files (and folders) from your shared drive to your local machine.

:code:`git commit -m "commit message"`: Once we reach a certain point in development, we want to "save" our changes . :code:`git commit` is like setting a checkpoint in the development process which you can go back to later if needed. Note that a commit message is required for a commit, this message ideally should be descriptive in documenting what we have developed or changed in the source code. For example, useful messages might look like, "capping all large losses at $250k", or "setting the reinsurance quota share to 25%". This is very similar to "save as", but in the git world. In addition, each commit compares and saves all differences since the previous commit, so we can easily compare changes between commits. This is similar to how we open two files and compare them side-by-side to spot the differences.

:code:`git branch <branch-name>`: Branches are very important when it comes to version control systems. By using branches, several developers are able to work in parallel on the same project simultaneously. We can use the :code:`git branch` command for creating, listing and deleting branches. Think of branching as creating a road marker, which represents an independent line of development. Do you want to find out what the indication would look like with a different trend? Or how the a-priori change with a different development patterns? These are all great use cases of branches, and branches allow different analysts to work on these changes simultaneously to be combined later. Setting branches are like marking the roads where we deviate from the main road, so we know what changes are made subsequently, before these changes are merged to the main road. This is also useful for developing experimental features that are not quite ready for production yet, for example, understanding what the indications would look like with different trend assumptions or using different sets of loss development pattern.

:code:`git checkout <name-of-your-branch>`: To work on a branch, we need to first be on that branch. We can use :code:`git checkout` to switch from one branch to another. But we can also use :code:`git checkout` for checking out specific files from another branch and a historical commit. Did another analyst update multiple files that we need from another branch? We can get on them by checking out the files on the branch. Or is there a new piece of code that was developed that we need to bring in? We can checkout a specific file that way.

:code:`git status`: How do we know what the current branch looks like (since the last commit) as we work on it over time? The :code:`git status` command gives us all the necessary information about the changes on the current branch. It will tell us if the current branch is up-to-date. Or whether there are files that had been created, modified, or deleted. Of if there are files staged (changes are tracked, and ready to be committed), unstaged (changes not tracked, not ready to be committed) or untracked (telling git to ignore these files). Or whether if there is anything to commit, push, or pull. This can help us stay organized and double-check before we commit the changes to the branch that we are on.

:code:`git add <files>`: From :code:`git status`, we can see a list of files that aren't tracked (or unstaged). We can add the files that we want staged for a commit by using :code:`git add`. For traditional practitioners, this is very similar to preparing a list of new files that we are ready to deploy to a centralized shared-folder. Note that in the git world, when a brand new file is created, it is untracked by default. We will need to use :code:`git add` to tell git that we want this new file tracked.

:code:`git push`: After adding and committing the changes, the next thing you want to do is send these changes to the remote server. :code:`git push` uploads all committed changes to the remote repository. Remember that unless we push the changes to the server, all changes made so far had only been for our local copy. This is similar to uploading our local files to the centralized server. Note that we don't have to push every time we make a commit.

:code:`git pull`: :code:`git pull` is the opposite of :code:`git push`, where we download updates from the remote server. This is similar to downloading the remote files to our local machine. Pulling is important because git will not tell us what has changed in the remote server. We have to pull to see those changes. 

:code:`git merge`: When we have completed development in our branch and everything works fine, the final step is merging the branch with the "main" branch. This is done with the :code:`git merge` command. :code:`git merge` basically integrates the experimental or developmental branch with all of its commits back to the main branch. It's important to remember that you first need to be on the specific branch that you want to merge with your feature branch. This is mainly used to consolidate different implemented changes between branches to and bring those changes together. Sometimes pushing and pulling will cause what is called a merge conflict, this is when git doesn't know how to resolve changes that are made on the local version of the file versus the remove version of the file. This can happen when code changes are made between multiple branches. While git is often smart enough to figure out what changes are newer, when it's ambiguous, it is up to the server to resolve these merge conflicts. 

:code:`git revert`: Sometimes we need to undo the changes that we've made. There are various ways to undo our changes locally or remotely, but we must carefully use these commands to avoid unwanted deletions.

There are many more git commands that might become useful for very specific use cases, but by understanding the basic commands above should allow you to have a basic understanding of how git works.
